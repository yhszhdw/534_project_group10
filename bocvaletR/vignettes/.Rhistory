0.9*49+0.1
t=c(6,7.366)
4*6^3/t^4
2/19
U=runif(1000)
x=5*U^(1/3)
mean(x)
U=runif(10000)
x=5*U^(1/3)
mean(x)
15/4
U=runif(10000)
x=5*U^(1/3)
var(x)
U=runif(100000)
x=5*U^(1/3)
var(x)
a=exp(2)
a/(1+a)
set.seed(26636)
b=arima.sim(1000,model=(ar=c(-0.4,0.3),order=c(2,1,0)),sd=1.5)
set.seed(26636)
b=arima.sim(1000,model=list(ar=c(-0.4,0.3),order=c(2,1,0)),sd=1.5)
b[500]
a=c(124,124,122,122)
b=c(127,122,123,127)
c=c(124,123,123,122)
median(a)
median(b)
median(c)
sd(c(123,123,125))
0.36*0.25+0.25
0.34*0.36+0.25
Q1_data=data("LakeHuron")
ts.plot(Q1_data,ylab='Lake Height (feet)',xlab='Year',main='Lake Huron Annual Water Levels')
Q1_data=data(LakeHuron)
ts.plot(Q1_data,ylab='Lake Height (feet)',xlab='Year',main='Lake Huron Annual Water Levels')
Q1_data=data(LakeHuron)
data(LakeHuron)
ts.plot(LakeHuron,ylab='Lake Height (feet)',xlab='Year',main='Lake Huron Annual Water Levels')
acf(LakeHuron)
model_1_c=arima(LakeHuron,order=c(1,0,0))
model_1_c=arima(LakeHuron,order=c(1,0,0))
summary(model_1_c)
model_1_c=arima(LakeHuron,order=c(1,0,0))
summary(model_1_c)
sqrt(model_1_c$sigma2)
sim_model_1_c=arima.sim(model_1_c,length(LakeHuron))
sim_model_1_c=arima.sim(length(LakeHuron),model=list(ar=model_1_c$coef[2]),sd=sqrt(model_1_c$sigma2))
sim_model_1_c=arima.sim(length(LakeHuron),model=list(ar=model_1_c$coef['ar1']),sd=sqrt(model_1_c$sigma2))
sims=replicate(
4,
arima.sim(length(LakeHuron),model=list(ar=model_1_c$coef['ar1']),sd=sqrt(model_1_c$sigma2)),
simplify = FALSE
)
par(mfrow = c(3,2))
acf(LakeHuron, main = "ACF: Original LakeHuron")
par(mfrow = c(3,2))
par(mar = c(4, 4, 2, 1))
acf(LakeHuron, main = "ACF: Original LakeHuron")
acf(sims[[1]], main = "ACF: Sim 1")
acf(sims[[2]], main = "ACF: Sim 2")
acf(sims[[3]], main = "ACF: Sim 3")
acf(sims[[4]], main = "ACF: Sim 4")
par(mfrow = c(1,1))
par(mfrow = c(3,2))
par(mar = c(4, 4, 3, 1))
acf(LakeHuron, main = "ACF: Original LakeHuron")
acf(sims[[1]], main = "ACF: Sim 1")
acf(sims[[2]], main = "ACF: Sim 2")
acf(sims[[3]], main = "ACF: Sim 3")
acf(sims[[4]], main = "ACF: Sim 4")
par(mfrow = c(1,1))
par(mfrow = c(3,2))
par(mar = c(4, 4, 3.5, 1))
acf(LakeHuron, main = "ACF: Original LakeHuron")
acf(sims[[1]], main = "ACF: Sim 1")
acf(sims[[2]], main = "ACF: Sim 2")
acf(sims[[3]], main = "ACF: Sim 3")
acf(sims[[4]], main = "ACF: Sim 4")
par(mfrow = c(1,1))
par(mfrow = c(3,2))
par(mar = c(4, 4, 3.5, 1))
ts.plot(LakeHuron, main = "Trace Pot: Original LakeHuron")
ts.plot(sims[[1]], main = "Trace Pot: Sim 1")
ts.plot(sims[[2]], main = "Trace Pot: Sim 2")
ts.plot(sims[[3]], main = "Trace Pot: Sim 3")
ts.plot(sims[[4]], main = "Trace Pot: Sim 4")
par(mfrow = c(1,1))
model_1_c$coef
set.seed(79486338)
sims=replicate(
4,
arima.sim(length(LakeHuron),model=list(ar=model_1_c$coef['ar1']),sd=sqrt(model_1_c$sigma2)+model_1_c$coef['intercept']),
simplify = FALSE
)
par(mfrow = c(3,2))
par(mar = c(4, 4, 3.5, 1))
acf(LakeHuron, main = "ACF: Original LakeHuron")
acf(sims[[1]], main = "ACF: Sim 1")
acf(sims[[2]], main = "ACF: Sim 2")
acf(sims[[3]], main = "ACF: Sim 3")
acf(sims[[4]], main = "ACF: Sim 4")
par(mfrow = c(1,1))
par(mfrow = c(3,2))
par(mar = c(4, 4, 3.5, 1))
ts.plot(LakeHuron, main = "Trace Pot: Original LakeHuron")
ts.plot(sims[[1]], main = "Trace Pot: Sim 1")
ts.plot(sims[[2]], main = "Trace Pot: Sim 2")
ts.plot(sims[[3]], main = "Trace Pot: Sim 3")
ts.plot(sims[[4]], main = "Trace Pot: Sim 4")
par(mfrow = c(1,1))
set.seed(79486338)
sims=replicate(
4,
arima.sim(length(LakeHuron),model=list(ar=model_1_c$coef['ar1']),sd=sqrt(model_1_c$sigma2))+model_1_c$coef['intercept'],
simplify = FALSE
)
par(mfrow = c(3,2))
par(mar = c(4, 4, 3.5, 1))
acf(LakeHuron, main = "ACF: Original LakeHuron")
acf(sims[[1]], main = "ACF: Sim 1")
acf(sims[[2]], main = "ACF: Sim 2")
acf(sims[[3]], main = "ACF: Sim 3")
acf(sims[[4]], main = "ACF: Sim 4")
par(mfrow = c(1,1))
par(mfrow = c(3,2))
par(mar = c(4, 4, 3.5, 1))
ts.plot(LakeHuron, main = "Trace Pot: Original LakeHuron")
ts.plot(sims[[1]], main = "Trace Pot: Sim 1")
ts.plot(sims[[2]], main = "Trace Pot: Sim 2")
ts.plot(sims[[3]], main = "Trace Pot: Sim 3")
ts.plot(sims[[4]], main = "Trace Pot: Sim 4")
par(mfrow = c(1,1))
set.seed(79486338)
Q2_sim=arima.sim(100,model=list(ar=c(0.2,0.6),order=c(2,0,0)),sd=1)
ts.plot(Q2_sim)
acf(Q2_sim)
set.seed(79486338)
Q2_sim=arima.sim(100,model=list(ar=c(0.2,-0.6),order=c(2,0,0)),sd=1)
ts.plot(Q2_sim)
set.seed(79486338)
Q2_sim_c=arima.sim(100,model=list(ar=c(0.2,-0.6),order=c(2,0,0)),sd=1)
ts.plot(Q2_sim_c)
acf(Q2_sim_c)
library(bocvaletR)
getwd()
setwd("C:/Users/18447/534_project_group10/bocvaletR/vignettes")
library(bocvaletR)
install.packages("remotes")
remotes::install_github("yhszhdw/534_project_group10@v0.9.2")
install.packages(
"https://github.com/yhszhdw/534_project_group10/releases/download/v0.9.2/bocvaletR_0.9.2.tar.gz",
repos = NULL,
type = "source"
)
library(bocvaletR)
boc_fx_rss_available()
View(sims)
View(sims)
LakeHuron
set.seed(79486338)
Q2_sim=ts(arima.sim(100,model=list(ar=c(0.2,0.6),order=c(2,0,0)),sd=1),start=1875,frequency = 1)
ts.plot(Q2_sim)
set.seed(79486338)
Q2_sim_c=ts(arima.sim(100,model=list(ar=c(0.2,-0.6),order=c(2,0,0)),sd=1),start=1875,frequency = 1)
ts.plot(Q2_sim_c)
acf(Q2_sim_c)
x <- seq(0, 1, length=100)
set.seed(79486338)
sims=replicate(
4,
ts((arima.sim(length(LakeHuron),model=list(ar=model_1_c$coef['ar1']),sd=sqrt(model_1_c$sigma2))+model_1_c$coef['intercept']),start=1875,frequency = 1),
simplify = FALSE
)
par(mfrow = c(3,2))
par(mar = c(4, 4, 3.5, 1))
acf(LakeHuron, main = "ACF: Original LakeHuron")
acf(sims[[1]], main = "ACF: Sim 1")
acf(sims[[2]], main = "ACF: Sim 2")
acf(sims[[3]], main = "ACF: Sim 3")
acf(sims[[4]], main = "ACF: Sim 4")
par(mfrow = c(1,1))
par(mfrow = c(3,2))
par(mar = c(4, 4, 3.5, 1))
ts.plot(LakeHuron, main = "Trace Pot: Original LakeHuron")
ts.plot(sims[[1]], main = "Trace Pot: Sim 1")
ts.plot(sims[[2]], main = "Trace Pot: Sim 2")
ts.plot(sims[[3]], main = "Trace Pot: Sim 3")
ts.plot(sims[[4]], main = "Trace Pot: Sim 4")
par(mfrow = c(1,1))
x <- seq(0, 1, length=100)
y0 = 2+3*x+rnorm(100)
y1 = arima.sim(100,model=list(ar=1,order=c(1,0,0)),sd=1)
x <- seq(0, 1, length=100)
y0 = 2+3*x+rnorm(100)
y1 = 2+3*x+arima.sim(100,model=list(ar=0.8),sd=1)
set.seed(1333)
x <- seq(0, 1, length=100)
y0 = 2+3*x+rnorm(100)
y1 = 2+3*x+as.numeric(arima.sim(100,model=list(ar=0.8),sd=1))
y0.lm <- lm(y0 ~ x)
y1.lm <- lm(y1 ~ x)
coef(y0.lm)
coef(y1.lm)
predict(y0.lm,0.8)
predict(y0.lm,data.frame(0.8))
predict(y0.lm, newdata = data.frame(x = 0.8))
predict(y1.lm, newdata = data.frame(x = 0.8))
print(paste('The predicted value of white noise model is',predict(y0.lm, newdata = data.frame(x = 0.8))))
print(paste('The predicted value of AR(1) model is' ,predict(y1.lm, newdata = data.frame(x = 0.8))))
print('The expected value is 4.4')
set.seed(79486338)
Q2_sim=ts(arima.sim(100,model=list(ar=c(0.2,0.6),order=c(2,0,0)),sd=1),start=1875,frequency = 1)
ts.plot(Q2_sim)
acf(Q2_sim)
pi.fun <- function(i){
out = 0
if (i>0) out=1/(i+1)^3
out
}
step_chain <- function(i){
u <- sample.int(6,1)
if (u == 1) j <- i - 2
else if (u == 2) j <- i - 1
else if (u == 3) j <- i + 1
else if (u == 4) j <- i + 2
else return(i)
if (j < 1) return(i)
a <- min(pi.fun(j) / pi.fun(i), 1)
if (runif(1) < a) j else i
}
run_chain <- function(n = 200000, burn = 20000, x0 = 10) {
x <- integer(n)
x[1] <- x0
for (t in 2:n) x[t] <- step_chain(x[t-1])
x_post <- x[(burn+1):n]
x_post
}
samples <- run_chain(n = 300000, burn = 50000, x0 = 10)
# Estimate stationary probabilities for small states (more stable)
max_state <- 200
tab <- table(factor(samples, levels = 1:max_state))
pi_hat <- as.numeric(tab) / length(samples)
# For each i, k_hat(i) = pi_hat(i) * (i+1)^3
i_vals <- 1:max_state
k_hat_i <- pi_hat * (i_vals + 1)^3
# Only use i where we have enough visits (avoid noisy tail)
min_count <- 50
keep <- as.numeric(tab) >= min_count
k_est <- mean(k_hat_i[keep])
k_se  <- sd(k_hat_i[keep]) / sqrt(sum(keep))
cat("Estimated k =", k_est, "\n")
cat("Monte Carlo SE (rough) =", k_se, "\n")
# Optional: compare to theoretical value
k_true <- 1 / (zeta(3) - 1)   # needs base R? zeta() is in 'pracma' or 'gsl'
run_chain <- function(n = 200000, burn = 20000, x0 = 10) {
x <- integer(n)
x[1] <- x0
for (t in 2:n) x[t] <- step_chain(x[t-1])
x_post <- x[(burn+1):n]
x_post
}
samples <- run_chain(n = 300000, burn = 50000, x0 = 10)
# Estimate stationary probabilities for small states (more stable)
max_state <- 200
tab <- table(factor(samples, levels = 1:max_state))
pi_hat <- as.numeric(tab) / length(samples)
# For each i, k_hat(i) = pi_hat(i) * (i+1)^3
i_vals <- 1:max_state
k_hat_i <- pi_hat * (i_vals + 1)^3
# Only use i where we have enough visits (avoid noisy tail)
min_count <- 50
keep <- as.numeric(tab) >= min_count
k_est <- mean(k_hat_i[keep])
k_se  <- sd(k_hat_i[keep]) / sqrt(sum(keep))
cat("Estimated k =", k_est, "\n")
cat("Monte Carlo SE (rough) =", k_se, "\n")
# If you don't have zeta(), hardcode Apéry's constant:
k_true2 <- 1 / (1.202056903159594 - 1)
cat("Hardcoded approx: k_true ≈", k_true2, "\n")
pi.fun <- function(i){
out = 0
if (i>0) out=1/(i+1)^3
out
}
Ntransitions <- 20000
X <- numeric(Ntransitions)
current.state <- 50 # initialize the Markov chain
for (n in 1:Ntransitions) {
i <- current.state
P <- c(min(pi.fun(i-2)/pi.fun(i), 1),
min(pi.fun(i-1)/pi.fun(i), 1),
min(pi.fun(i+1)/pi.fun(i), 1),
min(pi.fun(i+2)/pi.fun(i), 1))/6
P0 <- 1- sum(P)
P <- c(P[1:2], P0, P[3:4])
transition <- sample(seq(-2,2,1), size = 1, prob = P)
current.state <- current.state + transition
X[n] <- current.state
}
observedDist <- table(X[-c(1:1000)])
ts.plot(obsdrvedDist)
ts.plot(observedDist)
observedDist
ts.plot(observedDist)
observedDist
ts.plot(X)
pi_hat <- observedDist / sum(observedDist)
i_vals <- as.integer(names(pi_hat))
k_hat_i <- as.numeric(pi_hat) * (i_vals + 1)^3
k = observedDist[2]/19000*27
print(paste('The estimated value of k is',k))
dice_sums <- 2:12
dice_probs <- c(1,2,3,4,5,6,5,4,3,2,1)/36
next_pos <- function(i,s) {
((i-1+s)%%40)+1
}
build_P <- function() {
P<-matrix(0,nrow=50,ncol=40)
for (i in 1:40) {
if (i==31) {
P[i,11] <- 1
} else {
for (k in seq_along(dice_sums)){
s = dice_sum[k]
j = next_pos(i,s)
P[i,j] = P[i,j] + dice_probs[k]
}
}
}
P
}
P=build_P()
dice_sums <- 2:12
dice_probs <- c(1,2,3,4,5,6,5,4,3,2,1)/36
next_pos <- function(i,s) {
((i-1+s)%%40)+1
}
build_P <- function() {
P<-matrix(0,nrow=50,ncol=40)
for (i in 1:40) {
if (i==31) {
P[i,11] <- 1
} else {
for (k in seq_along(dice_sums)){
s = dice_sums[k]
j = next_pos(i,s)
P[i,j] = P[i,j] + dice_probs[k]
}
}
}
P
}
P=build_P()
dice_sums <- 2:12
dice_probs <- c(1,2,3,4,5,6,5,4,3,2,1)/36
next_pos <- function(i,s) {
((i-1+s)%%40)+1
}
build_P <- function() {
P<-matrix(0,nrow=40,ncol=40)
for (i in 1:40) {
if (i==31) {
P[i,11] <- 1
} else {
for (k in seq_along(dice_sums)){
s = dice_sums[k]
j = next_pos(i,s)
P[i,j] = P[i,j] + dice_probs[k]
}
}
}
P
}
P=build_P()
View(P)
View(P)
stationary_dist <- function(P) {
ev <- eigen(t(P))
idx <- which.min(abs(ev$values - 1))
v <- Re(ev$vectors[, idx])
PI <- v / sum(v)
as.numeric(PI)
}
PI <- stationary_dist(P)
names(PI) <- 1:40
barplot(PI, names.arg = 1:40, las = 2,
main = "Long-run distribution over Monopoly spaces",
xlab = "Space", ylab = "Probability")
ord=order(PI,decreasing=TRUE)
second_most=ord[2]
ord=order(PI,decreasing=TRUE)
second_most=ord[2]
print(paste('The second most visited is',second_most))
stationary_dist <- function(P) {
n=nrow(P)
A=diag(n)-t(P)
b=rep(0,n)
A[n,]=rep(1,n)
b[n]=1
PI=solve(A,b)
as.numeric(PI)
}
PI <- stationary_dist(P)
names(PI) <- 1:40
barplot(PI, names.arg = 1:40, las = 2,
main = "Long-run distribution over Monopoly spaces",
xlab = "Space", ylab = "Probability")
print(paste('The long run average amount of revenue is: ',PI[17]*950+PI[19]*950+PI[20]*1000))
print(paste('The long run average amount of the friend\'s revenue is: ',PI[38]*1500+PI[40]*2000))
print(paste('I will have a',PI[38]*1500+PI[40]*2000-(PI[17]*950+PI[19]*950+PI[20]*1000),'higher revenue than my firend'))
print(paste('I will have a',-(PI[38]*1500+PI[40]*2000)+(PI[17]*950+PI[19]*950+PI[20]*1000),'higher revenue than my firend'))
EX2=PI[17]*950^2+PI[19]*950^2+PI[20]*1000^2
EX=PI[17]*950+PI[19]*950+PI[20]*1000
VARX=EX2-EX^2
SDX=sqrt(VARX)
print(paste('The standard deviation of my profit is',SDX))
77^2
ER2=PI[17]*950^2+PI[19]*950^2+PI[20]*1000^2
ER=PI[17]*950+PI[19]*950+PI[20]*1000
VARR=EX2-EX^2
EC2=PI[38]*1500^2+PI[40]*2000^2
EC=PI[38]*1500+PI[40]*2000
VARC=EC2-EC^2
SDX=sqrt(VARR+VARC)
print(paste('The standard deviation of my profit is',SDX))
ER2=PI[22]*1050^2+PI[24]*1050^2+PI[25]*1100^2+PI[17]*950^2+PI[19]*950^2+PI[20]*1000^2
ER=PI[22]*1050+PI[24]*1050+PI[25]*1100+PI[17]*950+PI[19]*950+PI[20]*1000
VARR=EX2-EX^2
EC2=PI[38]*1500^2+PI[40]*2000^2+PI[32]*1275^2+PI[33]*1275^2+PI[35]*1400^2
EC=PI[38]*1500+PI[40]*2000+PI[32]*1275+PI[33]*1275+PI[35]*1400
VARC=EC2-EC^2
SDX=sqrt(VARR+VARC)
print(paste('The standard deviation of my profit is',SDX))
roll_dice <- function() {
sample.int(6, 1) + sample.int(6, 1)
}
move_player <- function(pos) {
if (pos == 31) {
return(11)
}
steps <- roll_dice()
new_pos <- ((pos - 1 + steps) %% 40) + 1
new_pos
}
simulate_game_dice <- function(rev_vec, cost_vec,
cash0 = 5000,
start_pos = 1,
max_turns = 1e6) {
me_pos  <- start_pos
op_pos  <- start_pos
me_cash <- cash0
op_cash <- cash0
for (t in 1:max_turns) {
# ---- You move ----
me_pos <- move_player(me_pos)
pay <- cost_vec[me_pos]
if (pay > 0) {
me_cash <- me_cash - pay
op_cash <- op_cash + pay
}
if (me_cash <= 0) return("lose")
# ---- Opponent moves ----
op_pos <- move_player(op_pos)
earn <- rev_vec[op_pos]
if (earn > 0) {
op_cash <- op_cash - earn
me_cash <- me_cash + earn
}
if (op_cash <= 0) return("win")
}
"timeout"
}
estimate_win_prob_dice <- function(rev_vec, cost_vec,
B = 1000,
seed = 79486338) {
set.seed(seed)
res <- replicate(B, simulate_game_dice(rev_vec, cost_vec))
list(
win_prob = mean(res == "win"),
wins = sum(res == "win"),
losses = sum(res == "lose"),
timeouts = sum(res == "timeout")
)
}
rev_cd <- rep(0, 40)
rev_cd[c(17, 19, 20)] <- c(950, 950, 1000)
cost_cd <- rep(0, 40)
cost_cd[c(38, 40)] <- c(1500, 2000)
out_cd <- estimate_win_prob_dice(rev_cd, cost_cd, B = 1000, seed = 1)
out_cd
rev_f <- rev_cd
rev_f[c(17, 19, 20, 22, 24, 25)] <- c(950, 950, 1000, 1050, 1050, 1100)
cost_f <- cost_cd
cost_f[c(38, 40, 32, 33, 35)] <- c(1500, 2000, 1275, 1275, 1400)
out_f <- estimate_win_prob_dice(rev_f, cost_f, B = 1000, seed = 2)
out_f
ER2=PI[17]*950^2+PI[19]*950^2+PI[20]*1000^2
ER=PI[17]*950+PI[19]*950+PI[20]*1000
VARR=ER2-ER^2
EC2=PI[38]*1500^2+PI[40]*2000^2
EC=PI[38]*1500+PI[40]*2000
VARC=EC2-EC^2
SDX=sqrt(VARR+VARC)
print(paste('The standard deviation of my profit is',SDX))
browseVignettes("bocvaletR")
install.packages(
"https://github.com/yhszhdw/534_project_group10/releases/download/v1.0.0/bocvaletR_1.0.0.tar.gz",
repos = NULL,
type = "source"
)
